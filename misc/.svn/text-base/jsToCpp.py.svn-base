import os
from os.path import join

def jsToCpp(engineDir):
   scriptFiles = ['error', 'sdb', 'help', 'sdbSP']
   sptDir = join(engineDir, 'spt')
   tbw = '' # short for to be written

   tbw += '// this file is automatically generated. DO NOT MODIFY IT!\n'
   tbw += '#include "ossTypes.h"\n'
   tbw += '#include "ossUtil.h"\n\n\n'

   # convert js file to a cpp array
   for filename in scriptFiles:
      inFile = open(join(sptDir, filename + '.js'),'rb')
      content = inFile.read()
      inFile.close()

      firstItem = True
      tbw += 'static CHAR ' + filename + '_js[] = {'
      for c in content:
         if firstItem:
            firstItem = False
         else:
            tbw += ','
         tbw += str(ord(c))
      tbw += '};\n'

   # generate file name array
   firstItem = True
   tbw += 'static CHAR* jsNameArray[] = {'
   for filename in scriptFiles:
      if firstItem:
         firstItem = False
      else:
         tbw += ','
      tbw += '"' + filename + '.js"'
   tbw += '};\n'

   # generate file text pointer array
   firstItem = True
   tbw += 'static CHAR* jsTextArray[] = {'
   for filename in scriptFiles:
      if firstItem:
         firstItem = False
      else:
         tbw += ','
      tbw += filename + '_js'
   tbw += '};\n'

   # generate file length array
   firstItem = True
   tbw += 'static UINT32 jsLenArray[] = {'
   for filename in scriptFiles:
      if firstItem:
         firstItem = False
      else:
         tbw += ','

      inFile = open(join(sptDir, filename + '.js'),'rb')
      content = inFile.read()
      inFile.close()
      tbw += str(len(content))
   tbw += '};\n'

   evalFuncStr = """static INT32 evalInitScripts( engine::Scope * scope )
{
   UINT32 i = 0 ;
   UINT32 len = sizeof ( jsNameArray ) / sizeof ( CHAR * ) ;
   INT32 rc = SDB_OK ;
   for ( ; i < len ; i++ )
   {
      if ( 0 == ossStrcmp( jsNameArray[i], "sdbSP.js" ) )
      {
         continue ;
      }
      rc = scope->evaluate( jsTextArray[i] , jsLenArray[i] , jsNameArray[i] , 1 , NULL ) ;
      if ( rc != SDB_OK )
      {
         PD_LOG ( PDERROR , "fail to eval init script: %s, rc=%d" , jsNameArray[i] , rc ) ;
         break ;
      }
   }
   return rc ;
}
"""

   evalFuncStr2 = """static INT32 evalInitScripts2( engine::_sptScope * scope )
{
   UINT32 i = 0 ;
   UINT32 len = sizeof ( jsNameArray ) / sizeof ( CHAR * ) ;
   INT32 rc = SDB_OK ;
   bson::BSONObj detail ;
   bson::BSONObj rval ;
   for ( ; i < len ; i++ )
   {
      rc = scope->eval( jsTextArray[i] , jsLenArray[i] , jsNameArray[i] ,
                        1 , SPT_EVAL_FLAG_NONE, rval, detail ) ;
      if ( rc != SDB_OK )
      {
         PD_LOG ( PDERROR , "fail to eval init script: %s, rc=%d" , jsNameArray[i] , rc ) ;
         break ;
      }
   }
   return rc ;
}
"""

   tbw += evalFuncStr

   tbw += evalFuncStr2

   outFile = open(join(sptDir, 'js_in_cpp.hpp'), 'w')
   outFile.write(tbw)
   outFile.close()

